{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Image from \"react-native-web/dist/exports/Image\";\nimport View from \"react-native-web/dist/exports/View\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport TouchableHighlight from \"react-native-web/dist/exports/TouchableHighlight\";\nimport TouchableOpacity from \"react-native-web/dist/exports/TouchableOpacity\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nvar reactNativePackage = require('react-native/package.json');\n\nvar splitVersion = reactNativePackage.version.split('.');\nvar majorVersion = +splitVersion[0];\nvar minorVersion = +splitVersion[1];\n\nvar ImageSlider = function (_Component) {\n  _inherits(ImageSlider, _Component);\n\n  var _super = _createSuper(ImageSlider);\n\n  function ImageSlider() {\n    var _this;\n\n    _classCallCheck(this, ImageSlider);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      position: 0,\n      width: Dimensions.get('window').width,\n      onPositionChangedCalled: false,\n      interval: null\n    };\n    _this._ref = null;\n    _this._panResponder = {};\n\n    _this._onRef = function (ref) {\n      _this._ref = ref;\n\n      if (ref && _this.state.position !== _this._getPosition()) {\n        _this._move(_this._getPosition());\n      }\n    };\n\n    _this._popHelperView = function () {\n      return !_this.props.loopBothSides && _this._getPosition() === 0 && _jsx(View, {\n        style: {\n          position: 'absolute',\n          width: 50,\n          height: '100%'\n        }\n      });\n    };\n\n    _this._move = function (index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var isUpdating = index !== _this._getPosition();\n\n      var x = Dimensions.get('window').width * index;\n      _this._ref && _this._ref.scrollTo({\n        y: 0,\n        x: x,\n        animated: animated\n      });\n\n      _this.setState({\n        position: index\n      });\n\n      if (isUpdating && _this.props.onPositionChanged && index < _this.props.images.length && index > -1) {\n        _this.props.onPositionChanged(index);\n\n        _this.setState({\n          onPositionChangedCalled: true\n        });\n      }\n\n      _this._setInterval();\n    };\n\n    _this._clearInterval = function () {\n      return _this.state.interval && clearInterval(_this.state.interval);\n    };\n\n    _this._setInterval = function () {\n      _this._clearInterval();\n\n      var _this$props = _this.props,\n          autoPlayWithInterval = _this$props.autoPlayWithInterval,\n          images = _this$props.images,\n          loop = _this$props.loop,\n          loopBothSides = _this$props.loopBothSides;\n\n      if (autoPlayWithInterval) {\n        _this.setState({\n          interval: setInterval(function () {\n            return _this._move(!(loop || loopBothSides) && _this.state.position === images.length - 1 ? 0 : _this.state.position + 1);\n          }, autoPlayWithInterval)\n        });\n      }\n    };\n\n    _this._handleScroll = function (event) {\n      var _this$state = _this.state,\n          position = _this$state.position,\n          width = _this$state.width;\n      var _this$props2 = _this.props,\n          loop = _this$props2.loop,\n          loopBothSides = _this$props2.loopBothSides,\n          images = _this$props2.images,\n          onPositionChanged = _this$props2.onPositionChanged;\n      var x = event.nativeEvent.contentOffset.x;\n\n      if ((loop || loopBothSides) && x.toFixed() >= +(width * images.length).toFixed()) {\n        return _this._move(0, false);\n      } else if (loopBothSides && x.toFixed() <= +(-width).toFixed()) {\n        return _this._move(images.length - 1, false);\n      }\n\n      var newPosition = 0;\n\n      if (position !== -1 && position !== images.length) {\n        newPosition = Math.round(event.nativeEvent.contentOffset.x / width);\n\n        _this.setState({\n          position: newPosition\n        });\n      }\n\n      if (onPositionChanged && !_this.state.onPositionChangedCalled && newPosition < images.length && newPosition > -1) {\n        onPositionChanged(newPosition);\n      } else {\n        _this.setState({\n          onPositionChangedCalled: false\n        });\n      }\n\n      _this._setInterval();\n    };\n\n    _this._onLayout = function () {\n      _this.setState({\n        width: Dimensions.get('window').width\n      });\n\n      _this._move(_this.state.position, false);\n    };\n\n    _this._renderImage = function (image, index) {\n      var _Dimensions$get = Dimensions.get('window'),\n          width = _Dimensions$get.width;\n\n      var _this$props3 = _this.props,\n          _onPress = _this$props3.onPress,\n          customSlide = _this$props3.customSlide;\n      var offset = {\n        marginLeft: index === -1 ? -width : 0\n      };\n      var imageStyle = [styles.image, {\n        width: width\n      }, offset];\n\n      if (customSlide) {\n        return customSlide({\n          item: image,\n          style: imageStyle,\n          index: index,\n          width: width\n        });\n      }\n\n      var imageObject = typeof image === 'string' ? {\n        uri: image\n      } : image;\n\n      var imageComponent = _jsx(Image, {\n        source: imageObject,\n        style: [imageStyle]\n      }, index);\n\n      if (_onPress) {\n        return _jsx(TouchableOpacity, {\n          style: [imageStyle, offset],\n          onPress: function onPress() {\n            return _onPress && _onPress({\n              image: image,\n              index: index\n            });\n          },\n          delayPressIn: 200,\n          children: imageComponent\n        }, index);\n      }\n\n      return imageComponent;\n    };\n\n    _this._scrollEnabled = function (position) {\n      return position !== -1 && position !== _this.props.images.length;\n    };\n\n    return _this;\n  }\n\n  _createClass(ImageSlider, [{\n    key: \"_getPosition\",\n    value: function _getPosition() {\n      if (typeof this.props.position === 'number') {\n        return this.props.position;\n      }\n\n      return this.state.position;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var position = this.props.position;\n\n      if (position && prevProps.position !== position) {\n        this._move(position);\n      }\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      this._setInterval();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._clearInterval();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props4 = this.props,\n          onPress = _this$props4.onPress,\n          customButtons = _this$props4.customButtons,\n          style = _this$props4.style,\n          loop = _this$props4.loop,\n          images = _this$props4.images,\n          loopBothSides = _this$props4.loopBothSides;\n\n      var position = this._getPosition();\n\n      var scrollEnabled = this._scrollEnabled(position);\n\n      return _jsxs(View, {\n        style: [styles.container, style],\n        onLayout: this._onLayout,\n        children: [_jsxs(ScrollView, {\n          onLayout: this._onLayout,\n          ref: function ref(_ref) {\n            return _this2._onRef(_ref);\n          },\n          onMomentumScrollEnd: this._handleScroll,\n          scrollEventThrottle: 16,\n          pagingEnabled: true,\n          bounces: loopBothSides,\n          contentInset: loopBothSides ? {\n            left: this.state.width\n          } : {},\n          horizontal: true,\n          scrollEnabled: scrollEnabled,\n          showsHorizontalScrollIndicator: false,\n          style: [styles.scrollViewContainer, style],\n          children: [loopBothSides && this._renderImage(images[images.length - 1], -1), images.map(this._renderImage), (loop || loopBothSides) && this._renderImage(images[0], images.length)]\n        }), customButtons ? customButtons(position, this._move) : _jsx(View, {\n          style: styles.buttons,\n          children: this.props.images.map(function (image, index) {\n            return _jsx(TouchableHighlight, {\n              underlayColor: \"#ccc\",\n              onPress: function onPress() {\n                return _this2._move(index);\n              },\n              style: [styles.button, position === index && styles.buttonSelected],\n              children: _jsx(View, {})\n            }, index);\n          })\n        }), this._popHelperView()]\n      });\n    }\n  }]);\n\n  return ImageSlider;\n}(Component);\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scrollViewContainer: {\n    flexDirection: 'row',\n    backgroundColor: '#222'\n  },\n  image: {\n    width: 200,\n    height: '100%'\n  },\n  buttons: {\n    height: 15,\n    marginTop: -25,\n    marginBottom: 10,\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexDirection: 'row'\n  },\n  button: {\n    margin: 3,\n    width: 8,\n    height: 8,\n    borderRadius: 8 / 2,\n    backgroundColor: '#ccc',\n    opacity: 0.9\n  },\n  buttonSelected: {\n    opacity: 1,\n    backgroundColor: '#fff'\n  }\n});\nexport default ImageSlider;","map":{"version":3,"sources":["D:/FYP/FYPNativeStuff/App/Archive/node_modules/react-native-image-slider/ImageSlider.js"],"names":["React","Component","reactNativePackage","require","splitVersion","version","split","majorVersion","minorVersion","ImageSlider","state","position","width","Dimensions","get","onPositionChangedCalled","interval","_ref","_panResponder","_onRef","ref","_getPosition","_move","_popHelperView","props","loopBothSides","height","index","animated","isUpdating","x","scrollTo","y","setState","onPositionChanged","images","length","_setInterval","_clearInterval","clearInterval","autoPlayWithInterval","loop","setInterval","_handleScroll","event","nativeEvent","contentOffset","toFixed","newPosition","Math","round","_onLayout","_renderImage","image","onPress","customSlide","offset","marginLeft","imageStyle","styles","item","style","imageObject","uri","imageComponent","_scrollEnabled","prevProps","customButtons","scrollEnabled","container","left","scrollViewContainer","map","buttons","button","buttonSelected","StyleSheet","create","flex","flexDirection","backgroundColor","marginTop","marginBottom","justifyContent","alignItems","margin","borderRadius","opacity"],"mappings":"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","sourcesContent":["// @flow\n\nimport React, { type Node, Component } from 'react';\nimport {\n  Image,\n  View,\n  ScrollView,\n  StyleSheet,\n  TouchableHighlight,\n  TouchableOpacity,\n  Dimensions,\n} from 'react-native';\n\nconst reactNativePackage = require('react-native/package.json');\nconst splitVersion = reactNativePackage.version.split('.');\nconst majorVersion = +splitVersion[0];\nconst minorVersion = +splitVersion[1];\n\ntype Slide = {\n  index: number,\n  style?: any,\n  width?: number,\n  item?: any,\n};\n\ntype PropsType = {\n  images: string[],\n  style?: any,\n  loop?: boolean,\n  loopBothSides?: boolean,\n  autoPlayWithInterval?: number,\n  position?: number,\n  onPositionChanged?: number => void,\n  onPress?: Object => void,\n  customButtons?: (number, (number, animated?: boolean) => void) => Node,\n  customSlide?: Slide => Node,\n};\n\ntype StateType = {\n  position: number,\n  width: number,\n  interval: any,\n  onPositionChangedCalled: boolean,\n};\n\nclass ImageSlider extends Component<PropsType, StateType> {\n  state = {\n    position: 0,\n    width: Dimensions.get('window').width,\n    onPositionChangedCalled: false,\n    interval: null,\n  };\n\n  _ref = null;\n  _panResponder = {};\n\n  _onRef = (ref: any) => {\n    this._ref = ref;\n    if (ref && this.state.position !== this._getPosition()) {\n      this._move(this._getPosition());\n    }\n  };\n\n  // In iOS you can pop view by swiping left, with active ScrollView\n  // you can't do that. This View on top of ScrollView enables call of\n  // pop function.\n  _popHelperView = () =>\n    !this.props.loopBothSides &&\n    this._getPosition() === 0 && (\n      <View style={{ position: 'absolute', width: 50, height: '100%' }} />\n    );\n\n  _move = (index: number, animated: boolean = true) => {\n    const isUpdating = index !== this._getPosition();\n    const x = Dimensions.get('window').width * index;\n\n    this._ref && this._ref.scrollTo({ y: 0, x, animated });\n\n    this.setState({ position: index });\n\n    if (\n      isUpdating &&\n      this.props.onPositionChanged &&\n      index < this.props.images.length &&\n      index > -1\n    ) {\n      this.props.onPositionChanged(index);\n      this.setState({ onPositionChangedCalled: true });\n    }\n\n    this._setInterval();\n  };\n\n  _getPosition() {\n    if (typeof this.props.position === 'number') {\n      return this.props.position;\n    }\n    return this.state.position;\n  }\n\n  componentDidUpdate(prevProps: Object) {\n    const { position } = this.props;\n\n    if (position && prevProps.position !== position) {\n      this._move(position);\n    }\n  }\n\n  _clearInterval = () =>\n    this.state.interval && clearInterval(this.state.interval);\n\n  _setInterval = () => {\n    this._clearInterval();\n    const { autoPlayWithInterval, images, loop, loopBothSides } = this.props;\n\n    if (autoPlayWithInterval) {\n      this.setState({\n        interval: setInterval(\n          () =>\n            this._move(\n              !(loop || loopBothSides) &&\n              this.state.position === images.length - 1\n                ? 0\n                : this.state.position + 1,\n            ),\n          autoPlayWithInterval,\n        ),\n      });\n    }\n  };\n\n  _handleScroll = (event: Object) => {\n    const { position, width } = this.state;\n    const { loop, loopBothSides, images, onPositionChanged } = this.props;\n    const { x } = event.nativeEvent.contentOffset;\n\n    if (\n      (loop || loopBothSides) &&\n      x.toFixed() >= +(width * images.length).toFixed()\n    ) {\n      return this._move(0, false);\n    } else if (loopBothSides && x.toFixed() <= +(-width).toFixed()) {\n      return this._move(images.length - 1, false);\n    }\n\n    let newPosition = 0;\n\n    if (position !== -1 && position !== images.length) {\n      newPosition = Math.round(event.nativeEvent.contentOffset.x / width);\n      this.setState({ position: newPosition });\n    }\n\n    if (\n      onPositionChanged &&\n      !this.state.onPositionChangedCalled &&\n      newPosition < images.length &&\n      newPosition > -1\n    ) {\n      onPositionChanged(newPosition);\n    } else {\n      this.setState({ onPositionChangedCalled: false });\n    }\n\n    this._setInterval();\n  };\n\n  componentWillMount() {\n    this._setInterval();\n  }\n\n  componentWillUnmount() {\n    this._clearInterval();\n  }\n\n  _onLayout = () => {\n    this.setState({ width: Dimensions.get('window').width });\n    this._move(this.state.position, false);\n  };\n\n  _renderImage = (image: any, index: number) => {\n    const { width } = Dimensions.get('window');\n    const { onPress, customSlide } = this.props;\n    const offset = { marginLeft: index === -1 ? -width : 0 };\n    const imageStyle = [styles.image, { width }, offset];\n\n    if (customSlide) {\n      return customSlide({ item: image, style: imageStyle, index, width });\n    }\n\n    const imageObject = typeof image === 'string' ? { uri: image } : image;\n\n    const imageComponent = (\n      <Image key={index} source={imageObject} style={[imageStyle]} />\n    );\n\n    if (onPress) {\n      return (\n        <TouchableOpacity\n          key={index}\n          style={[imageStyle, offset]}\n          onPress={() => onPress && onPress({ image, index })}\n          delayPressIn={200}\n        >\n          {imageComponent}\n        </TouchableOpacity>\n      );\n    }\n\n    return imageComponent;\n  };\n\n  // We make shure, that, when loop is active,\n  // fake images at the begin and at the end of ScrollView\n  // do not scroll.\n  _scrollEnabled = (position: number) =>\n    position !== -1 && position !== this.props.images.length;\n\n  render() {\n    const {\n      onPress,\n      customButtons,\n      style,\n      loop,\n      images,\n      loopBothSides,\n    } = this.props;\n    const position = this._getPosition();\n    const scrollEnabled = this._scrollEnabled(position);\n\n    return (\n      <View style={[styles.container, style]} onLayout={this._onLayout}>\n        <ScrollView\n          onLayout={this._onLayout}\n          ref={ref => this._onRef(ref)}\n          onMomentumScrollEnd={this._handleScroll}\n          scrollEventThrottle={16}\n          pagingEnabled={true}\n          bounces={loopBothSides}\n          contentInset={loopBothSides ? { left: this.state.width } : {}}\n          horizontal={true}\n          scrollEnabled={scrollEnabled}\n          showsHorizontalScrollIndicator={false}\n          style={[styles.scrollViewContainer, style]}\n        >\n          {loopBothSides && this._renderImage(images[images.length - 1], -1)}\n          {images.map(this._renderImage)}\n          {(loop || loopBothSides) &&\n            this._renderImage(images[0], images.length)}\n        </ScrollView>\n        {customButtons ? (\n          customButtons(position, this._move)\n        ) : (\n          <View style={styles.buttons}>\n            {this.props.images.map((image, index) => (\n              <TouchableHighlight\n                key={index}\n                underlayColor=\"#ccc\"\n                onPress={() => this._move(index)}\n                style={[\n                  styles.button,\n                  position === index && styles.buttonSelected,\n                ]}\n              >\n                <View />\n              </TouchableHighlight>\n            ))}\n          </View>\n        )}\n        {this._popHelperView()}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scrollViewContainer: {\n    flexDirection: 'row',\n    backgroundColor: '#222',\n  },\n  image: {\n    width: 200,\n    height: '100%',\n  },\n  buttons: {\n    height: 15,\n    marginTop: -25,\n    marginBottom: 10,\n    justifyContent: 'center',\n    alignItems: 'center',\n    flexDirection: 'row',\n  },\n  button: {\n    margin: 3,\n    width: 8,\n    height: 8,\n    borderRadius: 8 / 2,\n    backgroundColor: '#ccc',\n    opacity: 0.9,\n  },\n  buttonSelected: {\n    opacity: 1,\n    backgroundColor: '#fff',\n  },\n});\n\nexport default ImageSlider;\n"]},"metadata":{},"sourceType":"module"}